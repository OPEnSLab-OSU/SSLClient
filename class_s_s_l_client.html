<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSLClient: SSLClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SSLClient<span id="projectnumber">&#160;v1.6.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_s_s_l_client.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_s_l_client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SSLClient Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> class. Check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more info.  
 <a href="class_s_s_l_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_s_l_client_8h_source.html">SSLClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SSLClient:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_s_l_client.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a48239f60f1b4318cc112706fc40c6cea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6cea">Error</a> { <br />
&#160;&#160;<a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaa18dbddc0a3d4a94ee0f298fe55a06a94">SSL_OK</a> = 0
, <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaa7510402478ffbecd6e1aa3811b175cfd">SSL_CLIENT_CONNECT_FAIL</a> = 2
, <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaa6a9cc2412a53b5981e937a41523eece5">SSL_BR_CONNECT_FAIL</a> = 3
, <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaab8581e1172fbf15067d435706d3a03a8">SSL_CLIENT_WRTIE_ERROR</a> = 4
, <br />
&#160;&#160;<a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaa37bef298be71b84a57e59fadbfbd9016">SSL_BR_WRITE_ERROR</a> = 5
, <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaaf66f8d5f6601f9e7607b78bf7a07fc84">SSL_INTERNAL_ERROR</a> = 6
, <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6ceaa0a4f8af0226cf29ede8f6fe4a9047b08">SSL_OUT_OF_MEMORY</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a48239f60f1b4318cc112706fc40c6cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constants defining the possible errors encountered.  <a href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6cea">More...</a><br /></td></tr>
<tr class="separator:a48239f60f1b4318cc112706fc40c6cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af632625f8d247f3885c81e1f05043ad1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1">DebugLevel</a> { <br />
&#160;&#160;<a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a24122d1e1bb724237f305a0b4a21ff75">SSL_NONE</a> = 0
, <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a199742ec5c99c72d9cede1fda0f125c5">SSL_ERROR</a> = 1
, <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a26f3e5f1481f3ea22ea4ab5370b0fa97">SSL_WARN</a> = 2
, <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a8d5f7561f9cc0a2f3e5f362b02f4a5b2">SSL_INFO</a> = 3
, <br />
&#160;&#160;<a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1ad1cf0d4d876daa655edb8331bfe2ce39">SSL_DUMP</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:af632625f8d247f3885c81e1f05043ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of verbosity used in logging for <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>.  <a href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1">More...</a><br /></td></tr>
<tr class="separator:af632625f8d247f3885c81e1f05043ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68f026a625ca1ccd1aba87bb6e670376"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a68f026a625ca1ccd1aba87bb6e670376">SSLClient</a> (Client &amp;client, const br_x509_trust_anchor *trust_anchors, const size_t trust_anchors_num, const int analog_pin, const size_t max_sessions=1, const <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1">DebugLevel</a> debug=<a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a26f3e5f1481f3ea22ea4ab5370b0fa97">SSL_WARN</a>)</td></tr>
<tr class="memdesc:a68f026a625ca1ccd1aba87bb6e670376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> with all of the prerequisites needed.  <a href="class_s_s_l_client.html#a68f026a625ca1ccd1aba87bb6e670376">More...</a><br /></td></tr>
<tr class="separator:a68f026a625ca1ccd1aba87bb6e670376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c0745f65a6c6009ac938b3b9912c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ab97c0745f65a6c6009ac938b3b9912c3">connect</a> (IPAddress ip, uint16_t port) override</td></tr>
<tr class="memdesc:ab97c0745f65a6c6009ac938b3b9912c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect over SSL to a host specified by an IP address.  <a href="class_s_s_l_client.html#ab97c0745f65a6c6009ac938b3b9912c3">More...</a><br /></td></tr>
<tr class="separator:ab97c0745f65a6c6009ac938b3b9912c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248a5152cc3c3e7666bf5443bfd57c90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a248a5152cc3c3e7666bf5443bfd57c90">connect</a> (const char *host, uint16_t port) override</td></tr>
<tr class="memdesc:a248a5152cc3c3e7666bf5443bfd57c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect over SSL to a host specified by a hostname.  <a href="class_s_s_l_client.html#a248a5152cc3c3e7666bf5443bfd57c90">More...</a><br /></td></tr>
<tr class="separator:a248a5152cc3c3e7666bf5443bfd57c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c7926938acd57cfc3b982edf725a86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86">write</a> (const uint8_t *buf, size_t size) override</td></tr>
<tr class="memdesc:a03c7926938acd57cfc3b982edf725a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some bytes to the SSL connection.  <a href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86">More...</a><br /></td></tr>
<tr class="separator:a03c7926938acd57cfc3b982edf725a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7343a58457b4659f83b61cac1f442c3d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a7343a58457b4659f83b61cac1f442c3d">write</a> (uint8_t b) override</td></tr>
<tr class="separator:a7343a58457b4659f83b61cac1f442c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e775669b4a040fbd3f281dcbcd2de78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78">available</a> () override</td></tr>
<tr class="memdesc:a0e775669b4a040fbd3f281dcbcd2de78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes available to read from the data that has been received and decrypted.  <a href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78">More...</a><br /></td></tr>
<tr class="separator:a0e775669b4a040fbd3f281dcbcd2de78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5420541a06213133ae308a3bca1c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a4c5420541a06213133ae308a3bca1c95">read</a> (uint8_t *buf, size_t size) override</td></tr>
<tr class="memdesc:a4c5420541a06213133ae308a3bca1c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes read.  <a href="class_s_s_l_client.html#a4c5420541a06213133ae308a3bca1c95">More...</a><br /></td></tr>
<tr class="separator:a4c5420541a06213133ae308a3bca1c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1b52f4ad9633126cb68739175920eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#aef1b52f4ad9633126cb68739175920eb">read</a> () override</td></tr>
<tr class="memdesc:aef1b52f4ad9633126cb68739175920eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte, or -1 if none is available.  <a href="class_s_s_l_client.html#aef1b52f4ad9633126cb68739175920eb">More...</a><br /></td></tr>
<tr class="separator:aef1b52f4ad9633126cb68739175920eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b6f2ad25701d1e45adb613d072d86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a0c0b6f2ad25701d1e45adb613d072d86">peek</a> () override</td></tr>
<tr class="memdesc:a0c0b6f2ad25701d1e45adb613d072d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">View the first byte of the buffer, without removing it from the <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> Buffer.  <a href="class_s_s_l_client.html#a0c0b6f2ad25701d1e45adb613d072d86">More...</a><br /></td></tr>
<tr class="separator:a0c0b6f2ad25701d1e45adb613d072d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2192a6621fdf2f89cc26a9a1584f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#aaf2192a6621fdf2f89cc26a9a1584f8c">flush</a> () override</td></tr>
<tr class="memdesc:aaf2192a6621fdf2f89cc26a9a1584f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force writing the buffered bytes from <a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86" title="Write some bytes to the SSL connection.">SSLClient::write</a> to the network.  <a href="class_s_s_l_client.html#aaf2192a6621fdf2f89cc26a9a1584f8c">More...</a><br /></td></tr>
<tr class="separator:aaf2192a6621fdf2f89cc26a9a1584f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ed697371748e31e01c3f697bc36cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ad8ed697371748e31e01c3f697bc36cbe">stop</a> () override</td></tr>
<tr class="memdesc:ad8ed697371748e31e01c3f697bc36cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection.  <a href="class_s_s_l_client.html#ad8ed697371748e31e01c3f697bc36cbe">More...</a><br /></td></tr>
<tr class="separator:ad8ed697371748e31e01c3f697bc36cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5488f01ccfddfd9e41f54dfbda48bcae"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae">connected</a> () override</td></tr>
<tr class="memdesc:a5488f01ccfddfd9e41f54dfbda48bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the device is connected.  <a href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae">More...</a><br /></td></tr>
<tr class="separator:a5488f01ccfddfd9e41f54dfbda48bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee217b5558dfb0724f2319888a77256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#aeee217b5558dfb0724f2319888a77256">setMutualAuthParams</a> (const <a class="el" href="class_s_s_l_client_parameters.html">SSLClientParameters</a> &amp;params)</td></tr>
<tr class="memdesc:aeee217b5558dfb0724f2319888a77256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a client certificate and enable support for mutual auth.  <a href="class_s_s_l_client.html#aeee217b5558dfb0724f2319888a77256">More...</a><br /></td></tr>
<tr class="separator:aeee217b5558dfb0724f2319888a77256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd012ef6f01df9694ba9fd0a3c227c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_s_l_session.html">SSLSession</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2bd012ef6f01df9694ba9fd0a3c227c3">getSession</a> (const char *host)</td></tr>
<tr class="memdesc:a2bd012ef6f01df9694ba9fd0a3c227c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a session reference corresponding to a host and IP, or a reference to a empty session if none exist.  <a href="class_s_s_l_client.html#a2bd012ef6f01df9694ba9fd0a3c227c3">More...</a><br /></td></tr>
<tr class="separator:a2bd012ef6f01df9694ba9fd0a3c227c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d9d8a4187a3f8918bf66af83e733c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ad5d9d8a4187a3f8918bf66af83e733c4">removeSession</a> (const char *host)</td></tr>
<tr class="memdesc:ad5d9d8a4187a3f8918bf66af83e733c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the session corresponding to a host and IP.  <a href="class_s_s_l_client.html#ad5d9d8a4187a3f8918bf66af83e733c4">More...</a><br /></td></tr>
<tr class="separator:ad5d9d8a4187a3f8918bf66af83e733c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f9e6f8e8a50e520c936239abecfd22"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ae3f9e6f8e8a50e520c936239abecfd22">getSessionCount</a> () const</td></tr>
<tr class="memdesc:ae3f9e6f8e8a50e520c936239abecfd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of SSL sessions that can be stored at once.  <a href="class_s_s_l_client.html#ae3f9e6f8e8a50e520c936239abecfd22">More...</a><br /></td></tr>
<tr class="separator:ae3f9e6f8e8a50e520c936239abecfd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192ee3562c4806d4a6829356ca2636b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a4192ee3562c4806d4a6829356ca2636b">operator bool</a> ()</td></tr>
<tr class="memdesc:a4192ee3562c4806d4a6829356ca2636b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected()</a> &gt; 0.  <a href="class_s_s_l_client.html#a4192ee3562c4806d4a6829356ca2636b">More...</a><br /></td></tr>
<tr class="separator:a4192ee3562c4806d4a6829356ca2636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b2cbbb79dce7a86c64e3ad7fe46c97"><td class="memItemLeft" align="right" valign="top">Client &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a73b2cbbb79dce7a86c64e3ad7fe46c97">getClient</a> ()</td></tr>
<tr class="memdesc:a73b2cbbb79dce7a86c64e3ad7fe46c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the client object stored in this class. Take care not to break it.  <a href="class_s_s_l_client.html#a73b2cbbb79dce7a86c64e3ad7fe46c97">More...</a><br /></td></tr>
<tr class="separator:a73b2cbbb79dce7a86c64e3ad7fe46c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da354f30537c1064d554921937a73ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a8da354f30537c1064d554921937a73ae">setTimeout</a> (unsigned int t)</td></tr>
<tr class="memdesc:a8da354f30537c1064d554921937a73ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout when waiting for an SSL response.  <a href="class_s_s_l_client.html#a8da354f30537c1064d554921937a73ae">More...</a><br /></td></tr>
<tr class="separator:a8da354f30537c1064d554921937a73ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a178251978e0622f7e241da702ae498"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2a178251978e0622f7e241da702ae498">getTimeout</a> () const</td></tr>
<tr class="memdesc:a2a178251978e0622f7e241da702ae498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timeout when waiting for an SSL response.  <a href="class_s_s_l_client.html#a2a178251978e0622f7e241da702ae498">More...</a><br /></td></tr>
<tr class="separator:a2a178251978e0622f7e241da702ae498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab285c2f5a03124558ef7f74b9f3d12ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ab285c2f5a03124558ef7f74b9f3d12ad">setVerificationTime</a> (uint32_t days, uint32_t seconds)</td></tr>
<tr class="memdesc:ab285c2f5a03124558ef7f74b9f3d12ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the time used during x509 verification to a different value.  <a href="class_s_s_l_client.html#ab285c2f5a03124558ef7f74b9f3d12ad">More...</a><br /></td></tr>
<tr class="separator:ab285c2f5a03124558ef7f74b9f3d12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The main <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> class. Check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more info. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af632625f8d247f3885c81e1f05043ad1" name="af632625f8d247f3885c81e1f05043ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af632625f8d247f3885c81e1f05043ad1">&#9670;&#160;</a></span>DebugLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1">SSLClient::DebugLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Level of verbosity used in logging for <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>. </p>
<p >Use these values when initializing <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> to set how many logs you would like to see in the Serial monitor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af632625f8d247f3885c81e1f05043ad1a24122d1e1bb724237f305a0b4a21ff75" name="af632625f8d247f3885c81e1f05043ad1a24122d1e1bb724237f305a0b4a21ff75"></a>SSL_NONE&#160;</td><td class="fielddoc"><p >No logging output </p>
</td></tr>
<tr><td class="fieldname"><a id="af632625f8d247f3885c81e1f05043ad1a199742ec5c99c72d9cede1fda0f125c5" name="af632625f8d247f3885c81e1f05043ad1a199742ec5c99c72d9cede1fda0f125c5"></a>SSL_ERROR&#160;</td><td class="fielddoc"><p >Only output errors that result in connection failure </p>
</td></tr>
<tr><td class="fieldname"><a id="af632625f8d247f3885c81e1f05043ad1a26f3e5f1481f3ea22ea4ab5370b0fa97" name="af632625f8d247f3885c81e1f05043ad1a26f3e5f1481f3ea22ea4ab5370b0fa97"></a>SSL_WARN&#160;</td><td class="fielddoc"><p >Output errors and warnings (useful when just starting to develop) </p>
</td></tr>
<tr><td class="fieldname"><a id="af632625f8d247f3885c81e1f05043ad1a8d5f7561f9cc0a2f3e5f362b02f4a5b2" name="af632625f8d247f3885c81e1f05043ad1a8d5f7561f9cc0a2f3e5f362b02f4a5b2"></a>SSL_INFO&#160;</td><td class="fielddoc"><p >Output errors, warnings, and internal information (very verbose) </p>
</td></tr>
<tr><td class="fieldname"><a id="af632625f8d247f3885c81e1f05043ad1ad1cf0d4d876daa655edb8331bfe2ce39" name="af632625f8d247f3885c81e1f05043ad1ad1cf0d4d876daa655edb8331bfe2ce39"></a>SSL_DUMP&#160;</td><td class="fielddoc"><p >In addition to the above logs, dumps every byte in <a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86" title="Write some bytes to the SSL connection.">SSLClient::write</a> to the Serial monitor </p>
</td></tr>
</table>

</div>
</div>
<a id="a48239f60f1b4318cc112706fc40c6cea" name="a48239f60f1b4318cc112706fc40c6cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48239f60f1b4318cc112706fc40c6cea">&#9670;&#160;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_s_l_client.html#a48239f60f1b4318cc112706fc40c6cea">SSLClient::Error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Static constants defining the possible errors encountered. </p>
<p >If <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> encounters an error, it will generally output logs into the serial monitor. If you need a way of programmatically checking the errors, you can do so with SSLClient::getWriteError(), which will return one of these values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaa18dbddc0a3d4a94ee0f298fe55a06a94" name="a48239f60f1b4318cc112706fc40c6ceaa18dbddc0a3d4a94ee0f298fe55a06a94"></a>SSL_OK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaa7510402478ffbecd6e1aa3811b175cfd" name="a48239f60f1b4318cc112706fc40c6ceaa7510402478ffbecd6e1aa3811b175cfd"></a>SSL_CLIENT_CONNECT_FAIL&#160;</td><td class="fielddoc"><p >The underlying client failed to connect, probably not an issue with SSL </p>
</td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaa6a9cc2412a53b5981e937a41523eece5" name="a48239f60f1b4318cc112706fc40c6ceaa6a9cc2412a53b5981e937a41523eece5"></a>SSL_BR_CONNECT_FAIL&#160;</td><td class="fielddoc"><p >BearSSL failed to complete the SSL handshake, check logs for bear ssl error output </p>
</td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaab8581e1172fbf15067d435706d3a03a8" name="a48239f60f1b4318cc112706fc40c6ceaab8581e1172fbf15067d435706d3a03a8"></a>SSL_CLIENT_WRTIE_ERROR&#160;</td><td class="fielddoc"><p >The underlying client failed to write a payload, probably not an issue with SSL </p>
</td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaa37bef298be71b84a57e59fadbfbd9016" name="a48239f60f1b4318cc112706fc40c6ceaa37bef298be71b84a57e59fadbfbd9016"></a>SSL_BR_WRITE_ERROR&#160;</td><td class="fielddoc"><p >An internal error occurred with BearSSL, check logs for diagnosis. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaaf66f8d5f6601f9e7607b78bf7a07fc84" name="a48239f60f1b4318cc112706fc40c6ceaaf66f8d5f6601f9e7607b78bf7a07fc84"></a>SSL_INTERNAL_ERROR&#160;</td><td class="fielddoc"><p >An internal error occurred with <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>, and you probably need to submit an issue on Github. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48239f60f1b4318cc112706fc40c6ceaa0a4f8af0226cf29ede8f6fe4a9047b08" name="a48239f60f1b4318cc112706fc40c6ceaa0a4f8af0226cf29ede8f6fe4a9047b08"></a>SSL_OUT_OF_MEMORY&#160;</td><td class="fielddoc"><p ><a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> detected that there was not enough memory (&gt;8000 bytes) to continue. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68f026a625ca1ccd1aba87bb6e670376" name="a68f026a625ca1ccd1aba87bb6e670376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f026a625ca1ccd1aba87bb6e670376">&#9670;&#160;</a></span>SSLClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SSLClient::SSLClient </td>
          <td>(</td>
          <td class="paramtype">Client &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const br_x509_trust_anchor *&#160;</td>
          <td class="paramname"><em>trust_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>trust_anchors_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>analog_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_sessions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1">DebugLevel</a>&#160;</td>
          <td class="paramname"><em>debug</em> = <code><a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1a26f3e5f1481f3ea22ea4ab5370b0fa97">SSL_WARN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> with all of the prerequisites needed. </p>
<dl class="section pre"><dt>Precondition</dt><dd>You will need to generate an array of trust_anchors (root certificates) based off of the domains you want to make SSL connections to. Check out the <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> file for more info. </dd>
<dd>
The analog_pin should be set to input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The base network device to create an SSL socket on. This object will be copied and the copy will be stored in <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>. </td></tr>
    <tr><td class="paramname">trust_anchors</td><td>Trust anchors used in the verification of the SSL server certificate. Check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> for more info. </td></tr>
    <tr><td class="paramname">trust_anchors_num</td><td>The number of objects in the trust_anchors array. </td></tr>
    <tr><td class="paramname">analog_pin</td><td>An analog pin to pull random bytes from, used in seeding the RNG. </td></tr>
    <tr><td class="paramname">max_sessions</td><td>The maximum number of SSL sessions to store connection information from. </td></tr>
    <tr><td class="paramname">debug</td><td>The level of debug logging (use the <a class="el" href="class_s_s_l_client.html#af632625f8d247f3885c81e1f05043ad1" title="Level of verbosity used in logging for SSLClient.">DebugLevel</a> enum). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e775669b4a040fbd3f281dcbcd2de78" name="a0e775669b4a040fbd3f281dcbcd2de78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e775669b4a040fbd3f281dcbcd2de78">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes available to read from the data that has been received and decrypted. </p>
<p >This function updates the state of the SSL engine (including writing any data, see <a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86" title="Write some bytes to the SSL connection.">SSLClient::write</a>) and as a result should be called periodically when expecting data. Additionally, since if there are no bytes and if <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected</a> is false this function returns zero (this same behavior is found in EthernetClient), it is prudent to ensure in your own code that the preconditions are met before checking this function to prevent an ambiguous result.</p>
<p >The implementation for this function can be found in SSLClientImpl::available</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected</a> must be true. (Call <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected</a> before this function)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available (can be zero), or zero if any of the pre conditions aren't satisfied. </dd></dl>

</div>
</div>
<a id="a248a5152cc3c3e7666bf5443bfd57c90" name="a248a5152cc3c3e7666bf5443bfd57c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248a5152cc3c3e7666bf5443bfd57c90">&#9670;&#160;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect over SSL to a host specified by a hostname. </p>
<p >This function initializes the socket by calling m_client::connect(const char*, uint16_t) with the parameters supplied, then once the socket is open, uses BearSSL to complete a SSL handshake. This function runs until the SSL handshake succeeds or fails.</p>
<p >SSL requires the client to generate some random bits (to be later combined with some random bits from the server), so <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> uses the least significant bits from the analog pin supplied in the constructor. The random bits are generated from 16 consecutive analogReads, and given to BearSSL before the handshake starts.</p>
<p >This function will usually take around 4-10 seconds. If possible, this function also attempts to resume the SSL session if one is present matching the hostname string, which will reduce connection time to 100-500ms. To read more about this functionality, check out Session Caching in the README.</p>
<p >The implementation for this function can be found in SSLClientImpl::connect_impl(const char*, uint16_t)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying client object (passed in through the constructor) is in a non- error state, and must be able to access the IP. </dd>
<dd>
<a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> can only have one connection at a time, so the client object must not already be connected. </dd>
<dd>
There must be sufficient memory available on the device to verify the certificate (if the free memory drops below 8000 bytes during certain points in the connection, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> will fail). </dd>
<dd>
There must be a trust anchor given to the constructor that corresponds to the certificate provided by the IP address being connected to. For more information check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname as a null-terminated c-string ("www.google.com") </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to on the host (443 for HTTPS) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 of success, 0 if failure </dd></dl>

</div>
</div>
<a id="ab97c0745f65a6c6009ac938b3b9912c3" name="ab97c0745f65a6c6009ac938b3b9912c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c0745f65a6c6009ac938b3b9912c3">&#9670;&#160;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::connect </td>
          <td>(</td>
          <td class="paramtype">IPAddress&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect over SSL to a host specified by an IP address. </p>
<p >SSLClient::connect(host, port) should be preferred over this function, as verifying the domain name is a step in ensuring the certificate is legitimate, which is important to the security of the device. Additionally, SSL sessions cannot be resumed when using this function, which can drastically increase initial connect time.</p>
<p >This function initializes the socket by calling m_client::connect(IPAddress, uint16_t) with the parameters supplied, then once the socket is open, uses BearSSL to to complete a SSL handshake. Due to the design of the SSL standard, this function will probably take an extended period (1-4sec) to negotiate the handshake and finish the connection. This function runs until the SSL handshake succeeds or fails.</p>
<p >SSL requires the client to generate some random bits (to be later combined with some random bits from the server), so <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> uses the least significant bits from the analog pin supplied in the constructor. The random bits are generated from 16 consecutive analogReads, and given to BearSSL before the handshake starts.</p>
<p >The implementation for this function can be found in SSLClientImpl::connect_impl(IPAddress, uint16_t).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying client object (passed in through the constructor) is in a non- error state, and must be able to access the IP. </dd>
<dd>
<a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> can only have one connection at a time, so the client object must not already be connected. </dd>
<dd>
There must be sufficient memory available on the device to verify the certificate (if the free memory drops below 8000 bytes during certain points in the connection, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> will fail). </dd>
<dd>
There must be a trust anchor given to the constructor that corresponds to the certificate provided by the IP address being connected to. For more information check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>the port to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if failure </dd></dl>

</div>
</div>
<a id="a5488f01ccfddfd9e41f54dfbda48bcae" name="a5488f01ccfddfd9e41f54dfbda48bcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5488f01ccfddfd9e41f54dfbda48bcae">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SSLClient::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the device is connected. </p>
<p >Use this function to determine if <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> is still connected and a SSL connection is active. It should be noted that this function should be called before <a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a>&ndash; both functions send and receive data with the SSLClient::m_client device, however <a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> has some delays built in to protect SSLClient::m_client from being polled too frequently, and <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected</a> contains logic to ensure that if the socket is dropped <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> will react accordingly.</p>
<p >The implementation for this function can be found in SSLClientImpl::connected_impl.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if connected, 0 if not </dd></dl>

</div>
</div>
<a id="aaf2192a6621fdf2f89cc26a9a1584f8c" name="aaf2192a6621fdf2f89cc26a9a1584f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2192a6621fdf2f89cc26a9a1584f8c">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force writing the buffered bytes from <a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86" title="Write some bytes to the SSL connection.">SSLClient::write</a> to the network. </p>
<p >This function is blocking until all bytes from the buffer are written. For an explanation of how writing with <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> works, please see <a class="el" href="class_s_s_l_client.html#a03c7926938acd57cfc3b982edf725a86" title="Write some bytes to the SSL connection.">SSLClient::write</a>. The implementation for this function can be found in SSLClientImpl::flush. </p>

</div>
</div>
<a id="a73b2cbbb79dce7a86c64e3ad7fe46c97" name="a73b2cbbb79dce7a86c64e3ad7fe46c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b2cbbb79dce7a86c64e3ad7fe46c97">&#9670;&#160;</a></span>getClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Client &amp; SSLClient::getClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the client object stored in this class. Take care not to break it. </p>

</div>
</div>
<a id="a2bd012ef6f01df9694ba9fd0a3c227c3" name="a2bd012ef6f01df9694ba9fd0a3c227c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd012ef6f01df9694ba9fd0a3c227c3">&#9670;&#160;</a></span>getSession()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_s_l_session.html">SSLSession</a> * SSLClient::getSession </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a session reference corresponding to a host and IP, or a reference to a empty session if none exist. </p>
<p >If no session corresponding to the host and IP exist, then this function will cycle through sessions in a rotating order. This allows the session cache to continually store sessions, however it will also result in old sessions being cleared and returned. In general, it is a good idea to use a SessionCache size equal to the number of domains you plan on connecting to.</p>
<p >The implementation for this function can be found at SSLClientImpl::get_session_impl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A hostname c string, or NULL if one is not available </td></tr>
    <tr><td class="paramname">addr</td><td>An IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class_s_s_l_session.html" title="This class stores values which allow SSLClient to save and resume SSL sessions.">SSLSession</a>, or NULL of none matched the criteria available </dd></dl>

</div>
</div>
<a id="ae3f9e6f8e8a50e520c936239abecfd22" name="ae3f9e6f8e8a50e520c936239abecfd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f9e6f8e8a50e520c936239abecfd22">&#9670;&#160;</a></span>getSessionCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SSLClient::getSessionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of SSL sessions that can be stored at once. </p>
<dl class="section return"><dt>Returns</dt><dd>The SessionCache template parameter. </dd></dl>

</div>
</div>
<a id="a2a178251978e0622f7e241da702ae498" name="a2a178251978e0622f7e241da702ae498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a178251978e0622f7e241da702ae498">&#9670;&#160;</a></span>getTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SSLClient::getTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the timeout when waiting for an SSL response. </p>
<dl class="section return"><dt>Returns</dt><dd>The timeout value in milliseconds. </dd></dl>

</div>
</div>
<a id="a4192ee3562c4806d4a6829356ca2636b" name="a4192ee3562c4806d4a6829356ca2636b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4192ee3562c4806d4a6829356ca2636b">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SSLClient::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected()</a> &gt; 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if connected, false if not </dd></dl>

</div>
</div>
<a id="a0c0b6f2ad25701d1e45adb613d072d86" name="a0c0b6f2ad25701d1e45adb613d072d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0b6f2ad25701d1e45adb613d072d86">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View the first byte of the buffer, without removing it from the <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> Buffer. </p>
<p >The implementation for this function can be found in SSLClientImpl::peek </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> must be &gt;0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first byte received, or -1 if the preconditions are not satisfied (warning: do not use if your data may be -1, as the return value is ambiguous) </dd></dl>

</div>
</div>
<a id="aef1b52f4ad9633126cb68739175920eb" name="aef1b52f4ad9633126cb68739175920eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1b52f4ad9633126cb68739175920eb">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single byte, or -1 if none is available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_s_l_client.html#a4c5420541a06213133ae308a3bca1c95" title="Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes re...">SSLClient::read(uint8_t*, size_t)</a> </dd></dl>

</div>
</div>
<a id="a4c5420541a06213133ae308a3bca1c95" name="a4c5420541a06213133ae308a3bca1c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5420541a06213133ae308a3bca1c95">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SSLClient::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes read. </p>
<p >This function checks if bytes are ready to be read by calling <a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a>, and if so copies size number of bytes from the IO buffer into the buf pointer. Data read using this function will not include any SSL or socket commands, as the Client and BearSSL will capture those and process them separately.</p>
<p >If you find that you are having a lot of timeout errors, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> may be experiencing a buffer overflow. Checkout <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more information.</p>
<p >The implementation for this function can be found in SSLClientImpl::read_impl(uint8_t*, size_t)</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> must be &gt;0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer to put SSL application data into </td></tr>
    <tr><td class="paramname">size</td><td>The size (in bytes) to copy to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied (&lt;= size), or -1 if the preconditions are not satisfied. </dd></dl>

</div>
</div>
<a id="ad5d9d8a4187a3f8918bf66af83e733c4" name="ad5d9d8a4187a3f8918bf66af83e733c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d9d8a4187a3f8918bf66af83e733c4">&#9670;&#160;</a></span>removeSession()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::removeSession </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the session corresponding to a host and IP. </p>
<p >The implementation for this function can be found at SSLClientImpl::remove_session_impl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A hostname c string, or nullptr if one is not available </td></tr>
    <tr><td class="paramname">addr</td><td>An IP address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeee217b5558dfb0724f2319888a77256" name="aeee217b5558dfb0724f2319888a77256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee217b5558dfb0724f2319888a77256">&#9670;&#160;</a></span>setMutualAuthParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::setMutualAuthParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_s_l_client_parameters.html">SSLClientParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a client certificate and enable support for mutual auth. </p>
<p >Please ensure that the values in <code>params</code> are valid for the lifetime of <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>. You may want to make them global constants.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> has not already started an SSL connection. </dd></dl>

</div>
</div>
<a id="a8da354f30537c1064d554921937a73ae" name="a8da354f30537c1064d554921937a73ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da354f30537c1064d554921937a73ae">&#9670;&#160;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::setTimeout </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timeout when waiting for an SSL response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The timeout value, in milliseconds (defaults to 30 seconds if not set). Do not set to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab285c2f5a03124558ef7f74b9f3d12ad" name="ab285c2f5a03124558ef7f74b9f3d12ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab285c2f5a03124558ef7f74b9f3d12ad">&#9670;&#160;</a></span>setVerificationTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::setVerificationTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the time used during x509 verification to a different value. </p>
<p >This function directly calls br_x509_minimal_set_time to change the validation time used by the minimal verification engine. You can use this function if the default value of the compile time is causing issues. See <a href="https://bearssl.org/apidoc/bearssl__x509_8h.html#a7f3558b1999ce904084d578700b1002c">https://bearssl.org/apidoc/bearssl__x509_8h.html#a7f3558b1999ce904084d578700b1002c</a> for more information what this function does and how to use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">days</td><td>Days are counted in a proleptic Gregorian calendar since January 1st, 0 AD. </td></tr>
    <tr><td class="paramname">seconds</td><td>Seconds are counted since midnight, from 0 to 86400 (a count of 86400 is possible only if a leap second happened). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8ed697371748e31e01c3f697bc36cbe" name="ad8ed697371748e31e01c3f697bc36cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ed697371748e31e01c3f697bc36cbe">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SSLClient::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the connection. </p>
<p >If the SSL session is still active, all incoming data is discarded and BearSSL will attempt to close the session gracefully (will write to the network), and then call m_client::stop. If the session is not active or an error was encountered previously, this function will simply call m_client::stop. The implementation for this function can be found in SSLClientImpl::peek. </p>

</div>
</div>
<a id="a03c7926938acd57cfc3b982edf725a86" name="a03c7926938acd57cfc3b982edf725a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c7926938acd57cfc3b982edf725a86">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SSLClient::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some bytes to the SSL connection. </p>
<p >Assuming all preconditions are met, this function writes data to the BearSSL IO buffer, BUT does not initially send the data. Instead, you must call <a class="el" href="class_s_s_l_client.html#a0e775669b4a040fbd3f281dcbcd2de78" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> or <a class="el" href="class_s_s_l_client.html#aaf2192a6621fdf2f89cc26a9a1584f8c" title="Force writing the buffered bytes from SSLClient::write to the network.">SSLClient::flush</a>, which will detect that the buffer is ready for writing, and will write the data to the network. Alternatively, if this function is requested to write a larger amount of data than SSLClientImpl::m_iobuf can handle, data will be written to the network in pages the size of SSLClientImpl::m_iobuf until all the data in buf is sent&ndash;attempting to keep all writes to the network grouped together. For information on why this is the case check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> .</p>
<p >The implementation for this function can be found in SSLClientImpl::write_impl(const uint8_t*, size_t)</p>
<dl class="section pre"><dt>Precondition</dt><dd>The socket and SSL layer must be connected, meaning <a class="el" href="class_s_s_l_client.html#a5488f01ccfddfd9e41f54dfbda48bcae" title="Check if the device is connected.">SSLClient::connected</a> must be true. </dd>
<dd>
BearSSL must not be waiting for the recipt of user data (if it is, there is probably an error with how the protocol in implemented in your code).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the pointer to a buffer of bytes to copy </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to copy from the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied to the buffer (size), or zero if the BearSSL engine fails to become ready for writing data. </dd></dl>

</div>
</div>
<a id="a7343a58457b4659f83b61cac1f442c3d" name="a7343a58457b4659f83b61cac1f442c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7343a58457b4659f83b61cac1f442c3d">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SSLClient::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>SSLClient::write(uint8_t*, size_t) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_s_s_l_client_8h_source.html">SSLClient.h</a></li>
<li>src/<a class="el" href="_s_s_l_client_8cpp.html">SSLClient.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_s_l_client.html">SSLClient</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
