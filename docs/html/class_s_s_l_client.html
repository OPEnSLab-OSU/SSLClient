<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSLClient: SSLClient&lt; C, SessionCache &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SSLClient
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Add TLS 1.2 functionality to any network library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_s_s_l_client.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_s_s_l_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SSLClient&lt; C, SessionCache &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> class. Check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more info.  
 <a href="class_s_s_l_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_s_l_client_8h_source.html">SSLClient.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SSLClient&lt; C, SessionCache &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_s_l_client.png" usemap="#SSLClient_3C_20C_2C_20SessionCache_20_3E_map" alt=""/>
  <map id="SSLClient_3C_20C_2C_20SessionCache_20_3E_map" name="SSLClient_3C_20C_2C_20SessionCache_20_3E_map">
<area href="class_s_s_l_client_impl.html" title="Implementation code to be inherited by SSLClient." alt="SSLClientImpl" shape="rect" coords="0,56,190,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9a7509bc8a18f67e286547c19deb3c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ae9a7509bc8a18f67e286547c19deb3c0">SSLClient</a> (const C &amp;client, const br_x509_trust_anchor *trust_anchors, const size_t trust_anchors_num, const int analog_pin, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> debug=<a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395a86c8fdfc38831619d5ed73dff5b0911d">SSL_WARN</a>)</td></tr>
<tr class="memdesc:ae9a7509bc8a18f67e286547c19deb3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> with all of the prerequisites needed.  <a href="#ae9a7509bc8a18f67e286547c19deb3c0">More...</a><br /></td></tr>
<tr class="separator:ae9a7509bc8a18f67e286547c19deb3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2172aedfcc483ba2a256ad12148630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a4a2172aedfcc483ba2a256ad12148630">connect</a> (IPAddress ip, uint16_t port) override</td></tr>
<tr class="memdesc:a4a2172aedfcc483ba2a256ad12148630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect over SSL to a host specified by an IP address.  <a href="#a4a2172aedfcc483ba2a256ad12148630">More...</a><br /></td></tr>
<tr class="separator:a4a2172aedfcc483ba2a256ad12148630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c63e35f31652c20faa5b9be95984bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a91c63e35f31652c20faa5b9be95984bf">connect</a> (const char *host, uint16_t port) override</td></tr>
<tr class="memdesc:a91c63e35f31652c20faa5b9be95984bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect over SSL to a host specified by a hostname.  <a href="#a91c63e35f31652c20faa5b9be95984bf">More...</a><br /></td></tr>
<tr class="separator:a91c63e35f31652c20faa5b9be95984bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8ff53c10fe34aab1dc2561410f70bb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a6b8ff53c10fe34aab1dc2561410f70bb">write</a> (uint8_t b) override</td></tr>
<tr class="separator:a6b8ff53c10fe34aab1dc2561410f70bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcb7579ebc051c097acb794b95771a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a6bcb7579ebc051c097acb794b95771a9">write</a> (const uint8_t *buf, size_t size) override</td></tr>
<tr class="memdesc:a6bcb7579ebc051c097acb794b95771a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some bytes to the SSL connection.  <a href="#a6bcb7579ebc051c097acb794b95771a9">More...</a><br /></td></tr>
<tr class="separator:a6bcb7579ebc051c097acb794b95771a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d13fd2f32ee2ea65a1f3820f758e77e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e">available</a> () override</td></tr>
<tr class="memdesc:a5d13fd2f32ee2ea65a1f3820f758e77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes available to read from the data that has been received and decrypted.  <a href="#a5d13fd2f32ee2ea65a1f3820f758e77e">More...</a><br /></td></tr>
<tr class="separator:a5d13fd2f32ee2ea65a1f3820f758e77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf2746cc35da596faf8322776c2118e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#aedf2746cc35da596faf8322776c2118e">read</a> () override</td></tr>
<tr class="memdesc:aedf2746cc35da596faf8322776c2118e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte, or -1 if none is available.  <a href="#aedf2746cc35da596faf8322776c2118e">More...</a><br /></td></tr>
<tr class="separator:aedf2746cc35da596faf8322776c2118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6d7ae798c05cf566b2eb5651dba795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#afd6d7ae798c05cf566b2eb5651dba795">read</a> (uint8_t *buf, size_t size) override</td></tr>
<tr class="memdesc:afd6d7ae798c05cf566b2eb5651dba795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes read.  <a href="#afd6d7ae798c05cf566b2eb5651dba795">More...</a><br /></td></tr>
<tr class="separator:afd6d7ae798c05cf566b2eb5651dba795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31742867b00bd8d130637af0935bacbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a31742867b00bd8d130637af0935bacbd">peek</a> () override</td></tr>
<tr class="memdesc:a31742867b00bd8d130637af0935bacbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">View the first byte of the buffer, without removing it from the <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> Buffer.  <a href="#a31742867b00bd8d130637af0935bacbd">More...</a><br /></td></tr>
<tr class="separator:a31742867b00bd8d130637af0935bacbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee6a3134d07ca09cf61ee04d32c3d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2ee6a3134d07ca09cf61ee04d32c3d44">flush</a> () override</td></tr>
<tr class="memdesc:a2ee6a3134d07ca09cf61ee04d32c3d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force writing the buffered bytes from <a class="el" href="class_s_s_l_client.html#a6b8ff53c10fe34aab1dc2561410f70bb">SSLClient::write</a> to the network.  <a href="#a2ee6a3134d07ca09cf61ee04d32c3d44">More...</a><br /></td></tr>
<tr class="separator:a2ee6a3134d07ca09cf61ee04d32c3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30db47248d78df7c12dedfb27f06529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#ad30db47248d78df7c12dedfb27f06529">stop</a> () override</td></tr>
<tr class="memdesc:ad30db47248d78df7c12dedfb27f06529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection.  <a href="#ad30db47248d78df7c12dedfb27f06529">More...</a><br /></td></tr>
<tr class="separator:ad30db47248d78df7c12dedfb27f06529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e4414ab0c9424d09592f9567a678dc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc">connected</a> () override</td></tr>
<tr class="memdesc:a25e4414ab0c9424d09592f9567a678dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the device is connected.  <a href="#a25e4414ab0c9424d09592f9567a678dc">More...</a><br /></td></tr>
<tr class="separator:a25e4414ab0c9424d09592f9567a678dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8bf9b891151bc5b0b865d70cf9c086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_s_l_session.html">SSLSession</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2d8bf9b891151bc5b0b865d70cf9c086">getSession</a> (const char *host, const IPAddress &amp;addr)</td></tr>
<tr class="memdesc:a2d8bf9b891151bc5b0b865d70cf9c086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a session reference corresponding to a host and IP, or a reference to a empty session if none exist.  <a href="#a2d8bf9b891151bc5b0b865d70cf9c086">More...</a><br /></td></tr>
<tr class="separator:a2d8bf9b891151bc5b0b865d70cf9c086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b626703a24089dbb0480a9b6ddf348c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a5b626703a24089dbb0480a9b6ddf348c">removeSession</a> (const char *host, const IPAddress &amp;addr)</td></tr>
<tr class="memdesc:a5b626703a24089dbb0480a9b6ddf348c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the session corresponding to a host and IP.  <a href="#a5b626703a24089dbb0480a9b6ddf348c">More...</a><br /></td></tr>
<tr class="separator:a5b626703a24089dbb0480a9b6ddf348c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d71f00d6634092f50c5262ad25cdacd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2d71f00d6634092f50c5262ad25cdacd">getSessionCount</a> () const override</td></tr>
<tr class="memdesc:a2d71f00d6634092f50c5262ad25cdacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of SSL sessions that can be stored at once.  <a href="#a2d71f00d6634092f50c5262ad25cdacd">More...</a><br /></td></tr>
<tr class="separator:a2d71f00d6634092f50c5262ad25cdacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d378fbb7b8f15a1691746572f9d95b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a2d378fbb7b8f15a1691746572f9d95b1">operator bool</a> ()</td></tr>
<tr class="memdesc:a2d378fbb7b8f15a1691746572f9d95b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc" title="Check if the device is connected.">SSLClient::connected()</a> &gt; 0.  <a href="#a2d378fbb7b8f15a1691746572f9d95b1">More...</a><br /></td></tr>
<tr class="separator:a2d378fbb7b8f15a1691746572f9d95b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505bfb6831a45aebf58d84e3b89d4cfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a505bfb6831a45aebf58d84e3b89d4cfc">operator==</a> (const bool value)</td></tr>
<tr class="separator:a505bfb6831a45aebf58d84e3b89d4cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824b599264f893e1b206a9100bc52ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a824b599264f893e1b206a9100bc52ee1">operator!=</a> (const bool value)</td></tr>
<tr class="separator:a824b599264f893e1b206a9100bc52ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f40f8f4d26d21e14276c3e8162b62b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a5f40f8f4d26d21e14276c3e8162b62b9">operator==</a> (const C &amp;rhs)</td></tr>
<tr class="memdesc:a5f40f8f4d26d21e14276c3e8162b62b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not two <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> objects have the same underlying client object.  <a href="#a5f40f8f4d26d21e14276c3e8162b62b9">More...</a><br /></td></tr>
<tr class="separator:a5f40f8f4d26d21e14276c3e8162b62b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab82ba09345fa070712d3124af30e1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#adab82ba09345fa070712d3124af30e1b">operator!=</a> (const C &amp;rhs)</td></tr>
<tr class="memdesc:adab82ba09345fa070712d3124af30e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not two <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> objects do not have the same underlying client object.  <a href="#adab82ba09345fa070712d3124af30e1b">More...</a><br /></td></tr>
<tr class="separator:adab82ba09345fa070712d3124af30e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c5f9829757075bf16742cffa4cf73"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a563c5f9829757075bf16742cffa4cf73">localPort</a> () override</td></tr>
<tr class="memdesc:a563c5f9829757075bf16742cffa4cf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local port, C::localPort exists. Else return 0.  <a href="#a563c5f9829757075bf16742cffa4cf73">More...</a><br /></td></tr>
<tr class="separator:a563c5f9829757075bf16742cffa4cf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76a0df76834e0d0999dbf44c7c0a174"><td class="memItemLeft" align="right" valign="top">IPAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#af76a0df76834e0d0999dbf44c7c0a174">remoteIP</a> () override</td></tr>
<tr class="memdesc:af76a0df76834e0d0999dbf44c7c0a174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remote IP, if C::remoteIP exists. Else return INADDR_NONE.  <a href="#af76a0df76834e0d0999dbf44c7c0a174">More...</a><br /></td></tr>
<tr class="separator:af76a0df76834e0d0999dbf44c7c0a174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5974a5f8722a752f121af4fac498bb22"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a5974a5f8722a752f121af4fac498bb22">remotePort</a> () override</td></tr>
<tr class="memdesc:a5974a5f8722a752f121af4fac498bb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remote port, if C::remotePort exists. Else return 0.  <a href="#a5974a5f8722a752f121af4fac498bb22">More...</a><br /></td></tr>
<tr class="separator:a5974a5f8722a752f121af4fac498bb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d4d2c98433d60897d8828d8047d41"><td class="memItemLeft" align="right" valign="top">C &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#afd0d4d2c98433d60897d8828d8047d41">getClient</a> ()</td></tr>
<tr class="memdesc:afd0d4d2c98433d60897d8828d8047d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the client object stored in this class. Take care not to break it.  <a href="#afd0d4d2c98433d60897d8828d8047d41">More...</a><br /></td></tr>
<tr class="separator:afd0d4d2c98433d60897d8828d8047d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_s_s_l_client_impl"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_s_s_l_client_impl')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_s_s_l_client_impl.html">SSLClientImpl</a></td></tr>
<tr class="memitem:a2b0b9043c8252871272bf6ba199ab67b inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a2b0b9043c8252871272bf6ba199ab67b">SSLClientImpl</a> (const br_x509_trust_anchor *trust_anchors, const size_t trust_anchors_num, const int analog_pin, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> debug)</td></tr>
<tr class="separator:a2b0b9043c8252871272bf6ba199ab67b inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c14ecf301c268306946c85825e565b inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#aa5c14ecf301c268306946c85825e565b">connect_impl</a> (IPAddress ip, uint16_t port)</td></tr>
<tr class="separator:aa5c14ecf301c268306946c85825e565b inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c947ad92979ab99364428004abbeba inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#ae6c947ad92979ab99364428004abbeba">connect_impl</a> (const char *host, uint16_t port)</td></tr>
<tr class="separator:ae6c947ad92979ab99364428004abbeba inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807656f814f24cf6cd711e429b716c4d inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a807656f814f24cf6cd711e429b716c4d">write_impl</a> (const uint8_t *buf, size_t size)</td></tr>
<tr class="separator:a807656f814f24cf6cd711e429b716c4d inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33c793ec37f11087651cf4e586569b inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#abe33c793ec37f11087651cf4e586569b">available_impl</a> ()</td></tr>
<tr class="separator:abe33c793ec37f11087651cf4e586569b inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231b7b1bb2182cda1ed6e9d5ebf66afe inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a231b7b1bb2182cda1ed6e9d5ebf66afe">read_impl</a> (uint8_t *buf, size_t size)</td></tr>
<tr class="separator:a231b7b1bb2182cda1ed6e9d5ebf66afe inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90e7df3a77eea5efb955cc15a17f7d inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a1b90e7df3a77eea5efb955cc15a17f7d">peek_impl</a> ()</td></tr>
<tr class="separator:a1b90e7df3a77eea5efb955cc15a17f7d inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ab78a0917f74ae5383d688e1548788 inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a21ab78a0917f74ae5383d688e1548788">flush_impl</a> ()</td></tr>
<tr class="separator:a21ab78a0917f74ae5383d688e1548788 inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb5ede3a894f281ae586d463b624e6 inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a81eb5ede3a894f281ae586d463b624e6">stop_impl</a> ()</td></tr>
<tr class="separator:a81eb5ede3a894f281ae586d463b624e6 inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957984fa392550a7df86f758e9b14bfb inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a957984fa392550a7df86f758e9b14bfb">connected_impl</a> ()</td></tr>
<tr class="separator:a957984fa392550a7df86f758e9b14bfb inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e38d4319ec504395d67d2ab21a639e inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_s_l_session.html">SSLSession</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#ab4e38d4319ec504395d67d2ab21a639e">get_session_impl</a> (const char *host, const IPAddress &amp;addr)</td></tr>
<tr class="separator:ab4e38d4319ec504395d67d2ab21a639e inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baed094969874fb9d2bea3a00ecbee1 inherit pub_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a6baed094969874fb9d2bea3a00ecbee1">remove_session_impl</a> (const char *host, const IPAddress &amp;addr)</td></tr>
<tr class="separator:a6baed094969874fb9d2bea3a00ecbee1 inherit pub_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c5001bdfa75ccc0d93cc60dd872b38a"><td class="memItemLeft" align="right" valign="top">Client &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a9c5001bdfa75ccc0d93cc60dd872b38a">get_arduino_client</a> () override</td></tr>
<tr class="memdesc:a9c5001bdfa75ccc0d93cc60dd872b38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of m_client that is polymorphic and can be used by <a class="el" href="class_s_s_l_client_impl.html" title="Implementation code to be inherited by SSLClient.">SSLClientImpl</a>.  <a href="#a9c5001bdfa75ccc0d93cc60dd872b38a">More...</a><br /></td></tr>
<tr class="separator:a9c5001bdfa75ccc0d93cc60dd872b38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353c875d17a85dbb7bfe10de155f3b52"><td class="memItemLeft" align="right" valign="top">const Client &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a353c875d17a85dbb7bfe10de155f3b52">get_arduino_client</a> () const override</td></tr>
<tr class="separator:a353c875d17a85dbb7bfe10de155f3b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7769fed78825cf4723778f4b5aa3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_s_l_session.html">SSLSession</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a9e7769fed78825cf4723778f4b5aa3e9">get_session_array</a> () override</td></tr>
<tr class="memdesc:a9e7769fed78825cf4723778f4b5aa3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the session array that is on the stack.  <a href="#a9e7769fed78825cf4723778f4b5aa3e9">More...</a><br /></td></tr>
<tr class="separator:a9e7769fed78825cf4723778f4b5aa3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18adfc074d6b8e996819d4beb4689cbd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_s_l_session.html">SSLSession</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client.html#a18adfc074d6b8e996819d4beb4689cbd">get_session_array</a> () const override</td></tr>
<tr class="separator:a18adfc074d6b8e996819d4beb4689cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_s_s_l_client_impl"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_s_s_l_client_impl')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_s_s_l_client_impl.html">SSLClientImpl</a></td></tr>
<tr class="memitem:a9ee82ad492f2297bd7cd0835c0d4556f inherit pro_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a9ee82ad492f2297bd7cd0835c0d4556f">m_print_prefix</a> (const char *func_name, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> level) const</td></tr>
<tr class="memdesc:a9ee82ad492f2297bd7cd0835c0d4556f inherit pro_methods_class_s_s_l_client_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a debugging prefix to all logs, so we can attatch them to useful information.  <a href="class_s_s_l_client_impl.html#a9ee82ad492f2297bd7cd0835c0d4556f">More...</a><br /></td></tr>
<tr class="separator:a9ee82ad492f2297bd7cd0835c0d4556f inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e701597178b81f10d0db671b81ab075 inherit pro_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a6e701597178b81f10d0db671b81ab075">m_print_ssl_error</a> (const int ssl_error, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> level) const</td></tr>
<tr class="memdesc:a6e701597178b81f10d0db671b81ab075 inherit pro_methods_class_s_s_l_client_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the string associated with a write error.  <a href="class_s_s_l_client_impl.html#a6e701597178b81f10d0db671b81ab075">More...</a><br /></td></tr>
<tr class="separator:a6e701597178b81f10d0db671b81ab075 inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf492a714cf787e54a17bb47cda43ed inherit pro_methods_class_s_s_l_client_impl"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a2cf492a714cf787e54a17bb47cda43ed">m_print_br_error</a> (const unsigned br_error_code, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> level) const</td></tr>
<tr class="memdesc:a2cf492a714cf787e54a17bb47cda43ed inherit pro_methods_class_s_s_l_client_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the text string associated with a BearSSL error code.  <a href="class_s_s_l_client_impl.html#a2cf492a714cf787e54a17bb47cda43ed">More...</a><br /></td></tr>
<tr class="separator:a2cf492a714cf787e54a17bb47cda43ed inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a1967029784a2f0f3edc7f75a00117 inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45a1967029784a2f0f3edc7f75a00117 inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a45a1967029784a2f0f3edc7f75a00117">m_print</a> (const T str, const char *func_name, const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a> level) const</td></tr>
<tr class="memdesc:a45a1967029784a2f0f3edc7f75a00117 inherit pro_methods_class_s_s_l_client_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">debugging print function, only prints if m_debug is true  <a href="class_s_s_l_client_impl.html#a45a1967029784a2f0f3edc7f75a00117">More...</a><br /></td></tr>
<tr class="separator:a45a1967029784a2f0f3edc7f75a00117 inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cb1e9e510955078b83c9f84c0e18c inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b4cb1e9e510955078b83c9f84c0e18c inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a3b4cb1e9e510955078b83c9f84c0e18c">m_info</a> (const T str, const char *func_name) const</td></tr>
<tr class="memdesc:a3b4cb1e9e510955078b83c9f84c0e18c inherit pro_methods_class_s_s_l_client_impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a info message to serial, if info messages are enabled.  <a href="class_s_s_l_client_impl.html#a3b4cb1e9e510955078b83c9f84c0e18c">More...</a><br /></td></tr>
<tr class="separator:a3b4cb1e9e510955078b83c9f84c0e18c inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfb55bcde46d8d77a46bfe0f577bf3f inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bfb55bcde46d8d77a46bfe0f577bf3f inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#a2bfb55bcde46d8d77a46bfe0f577bf3f">m_warn</a> (const T str, const char *func_name) const</td></tr>
<tr class="separator:a2bfb55bcde46d8d77a46bfe0f577bf3f inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada595ed8f11673a9180ef0b762949c83 inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada595ed8f11673a9180ef0b762949c83 inherit pro_methods_class_s_s_l_client_impl"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_s_l_client_impl.html#ada595ed8f11673a9180ef0b762949c83">m_error</a> (const T str, const char *func_name) const</td></tr>
<tr class="separator:ada595ed8f11673a9180ef0b762949c83 inherit pro_methods_class_s_s_l_client_impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class C, size_t SessionCache = 1&gt;<br />
class SSLClient&lt; C, SessionCache &gt;</h3>

<p>The main <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> class. Check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more info. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae9a7509bc8a18f67e286547c19deb3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a7509bc8a18f67e286547c19deb3c0">&#9670;&nbsp;</a></span>SSLClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::<a class="el" href="class_s_s_l_client.html">SSLClient</a> </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const br_x509_trust_anchor *&#160;</td>
          <td class="paramname"><em>trust_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>trust_anchors_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>analog_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395">DebugLevel</a>&#160;</td>
          <td class="paramname"><em>debug</em> = <code><a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395a86c8fdfc38831619d5ed73dff5b0911d">SSL_WARN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> with all of the prerequisites needed. </p>
<dl class="section pre"><dt>Precondition</dt><dd>You will need to generate an array of trust_anchors (root certificates) based off of the domains you want to make SSL connections to. Check out the <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> file for more info. </dd>
<dd>
The analog_pin should be set to input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The base network device to create an SSL socket on. This object will be copied and the copy will be stored in <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a>. </td></tr>
    <tr><td class="paramname">trust_anchors</td><td>Trust anchors used in the verification of the SSL server certificate. Check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> for more info. </td></tr>
    <tr><td class="paramname">trust_anchors_num</td><td>The number of objects in the trust_anchors array. </td></tr>
    <tr><td class="paramname">analog_pin</td><td>An analog pin to pull random bytes from, used in seeding the RNG. </td></tr>
    <tr><td class="paramname">debug</td><td>The level of debug logging (use the <a class="el" href="_s_s_l_client_impl_8h.html#ab658e6d84759440dbf3c890446075395" title="Level of verbosity used in logging for SSLClient.">DebugLevel</a> enum). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d13fd2f32ee2ea65a1f3820f758e77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d13fd2f32ee2ea65a1f3820f758e77e">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes available to read from the data that has been received and decrypted. </p>
<p>This function updates the state of the SSL engine (including writing any data, see <a class="el" href="class_s_s_l_client.html#a6b8ff53c10fe34aab1dc2561410f70bb">SSLClient::write</a>) and as a result should be called periodically when expecting data. Additionally, since if there are no bytes and if <a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc" title="Check if the device is connected.">SSLClient::connected</a> is false this function returns zero (this same behavior is found in EthernetClient), it is prudent to ensure in your own code that the preconditions are met before checking this function to prevent an ambiguous result.</p>
<p>The implementation for this function can be found in SSLClientImpl::available</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc" title="Check if the device is connected.">SSLClient::connected</a> must be true.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available (can be zero), or zero if any of the pre conditions aren't satisfied. </dd></dl>

</div>
</div>
<a id="a4a2172aedfcc483ba2a256ad12148630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2172aedfcc483ba2a256ad12148630">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">IPAddress&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect over SSL to a host specified by an IP address. </p>
<p>SSLClient::connect(host, port) should be preferred over this function, as verifying the domain name is a step in ensuring the certificate is legitimate, which is important to the security of the device. Additionally, SSL sessions cannot be resumed when using this function, which can drastically increase initial connect time.</p>
<p>This function initializes the socket by calling m_client::connect(IPAddress, uint16_t) with the parameters supplied, then once the socket is open, uses BearSSL to to complete a SSL handshake. Due to the design of the SSL standard, this function will probably take an extended period (1-4sec) to negotiate the handshake and finish the connection. This function runs until the SSL handshake succeeds or fails.</p>
<p>SSL requires the client to generate some random bits (to be later combined with some random bits from the server), so <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> uses the least significant bits from the analog pin supplied in the constructor. The random bits are generated from 16 consecutive analogReads, and given to BearSSL before the handshake starts.</p>
<p>The implementation for this function can be found in <a class="el" href="class_s_s_l_client_impl.html#aa5c14ecf301c268306946c85825e565b">SSLClientImpl::connect_impl(IPAddress, uint16_t)</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying client object (passed in through the constructor) is in a non- error state, and must be able to access the IP. </dd>
<dd>
<a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> can only have one connection at a time, so the client object must not already be connected. </dd>
<dd>
There must be sufficient memory available on the device to verify the certificate (if the free memory drops below 8000 bytes during certain points in the connection, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> will fail). </dd>
<dd>
There must be a trust anchor given to the constructor that corresponds to the certificate provided by the IP address being connected to. For more information check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>the port to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if failure </dd></dl>

</div>
</div>
<a id="a91c63e35f31652c20faa5b9be95984bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c63e35f31652c20faa5b9be95984bf">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect over SSL to a host specified by a hostname. </p>
<p>This function initializes the socket by calling m_client::connect(const char*, uint16_t) with the parameters supplied, then once the socket is open, uses BearSSL to complete a SSL handshake. This function runs until the SSL handshake succeeds or fails.</p>
<p>SSL requires the client to generate some random bits (to be later combined with some random bits from the server), so <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> uses the least significant bits from the analog pin supplied in the constructor. The random bits are generated from 16 consecutive analogReads, and given to BearSSL before the handshake starts.</p>
<p>This function will usually take around 4-10 seconds. If possible, this function also attempts to resume the SSL session if one is present matching the hostname string, which will reduce connection time to 100-500ms. To read more about this functionality, check out Session Caching in the README.</p>
<p>The implementation for this function can be found in <a class="el" href="class_s_s_l_client_impl.html#ae6c947ad92979ab99364428004abbeba">SSLClientImpl::connect_impl(const char*, uint16_t)</a></p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying client object (passed in through the constructor) is in a non- error state, and must be able to access the IP. </dd>
<dd>
<a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> can only have one connection at a time, so the client object must not already be connected. </dd>
<dd>
There must be sufficient memory available on the device to verify the certificate (if the free memory drops below 8000 bytes during certain points in the connection, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> will fail). </dd>
<dd>
There must be a trust anchor given to the constructor that corresponds to the certificate provided by the IP address being connected to. For more information check out <a class="el" href="_trust_anchors_8md.html">TrustAnchors.md</a> .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The hostname as a null-terminated c-string ("www.google.com") </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to on the host (443 for HTTPS) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 of success, 0 if failure </dd></dl>

</div>
</div>
<a id="a25e4414ab0c9424d09592f9567a678dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e4414ab0c9424d09592f9567a678dc">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the device is connected. </p>
<p>Use this function to determine if <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> is still connected and a SSL connection is active. It should be noted that <a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> should be preferred over this function for rapid polling&ndash;both functions send and receive data with the SSLClient::m_client device, however <a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> has some delays built in to protect SSLClient::m_client from being polled too frequently.</p>
<p>The implementation for this function can be found in <a class="el" href="class_s_s_l_client_impl.html#a957984fa392550a7df86f758e9b14bfb">SSLClientImpl::connected_impl</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if connected, 0 if not </dd></dl>

</div>
</div>
<a id="a2ee6a3134d07ca09cf61ee04d32c3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee6a3134d07ca09cf61ee04d32c3d44">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force writing the buffered bytes from <a class="el" href="class_s_s_l_client.html#a6b8ff53c10fe34aab1dc2561410f70bb">SSLClient::write</a> to the network. </p>
<p>This function is blocking until all bytes from the buffer are written. For an explanation of how writing with <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> works, please see <a class="el" href="class_s_s_l_client.html#a6b8ff53c10fe34aab1dc2561410f70bb">SSLClient::write</a>. The implementation for this function can be found in SSLClientImpl::flush. </p>

</div>
</div>
<a id="a9c5001bdfa75ccc0d93cc60dd872b38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5001bdfa75ccc0d93cc60dd872b38a">&#9670;&nbsp;</a></span>get_arduino_client() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Client&amp; <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::get_arduino_client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of m_client that is polymorphic and can be used by <a class="el" href="class_s_s_l_client_impl.html" title="Implementation code to be inherited by SSLClient.">SSLClientImpl</a>. </p>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#a20dd9a9794b95719e6f3df8cb39126e3">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a353c875d17a85dbb7bfe10de155f3b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c875d17a85dbb7bfe10de155f3b52">&#9670;&nbsp;</a></span>get_arduino_client() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Client&amp; <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::get_arduino_client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#ab1c8f30bd3669c15e07fa1522ede4336">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a9e7769fed78825cf4723778f4b5aa3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7769fed78825cf4723778f4b5aa3e9">&#9670;&nbsp;</a></span>get_session_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_s_l_session.html">SSLSession</a>* <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::get_session_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of the session array that is on the stack. </p>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#a44cfafd6f5cdcaa5dbac22961ab3a58b">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a18adfc074d6b8e996819d4beb4689cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18adfc074d6b8e996819d4beb4689cbd">&#9670;&nbsp;</a></span>get_session_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_s_l_session.html">SSLSession</a>* <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::get_session_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#ace6652307ba028d67c7ddbc4103fa9b4">SSLClientImpl</a>.</p>

</div>
</div>
<a id="afd0d4d2c98433d60897d8828d8047d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d4d2c98433d60897d8828d8047d41">&#9670;&nbsp;</a></span>getClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C&amp; <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::getClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the client object stored in this class. Take care not to break it. </p>

</div>
</div>
<a id="a2d8bf9b891151bc5b0b865d70cf9c086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8bf9b891151bc5b0b865d70cf9c086">&#9670;&nbsp;</a></span>getSession()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_s_l_session.html">SSLSession</a>&amp; <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::getSession </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IPAddress &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a session reference corresponding to a host and IP, or a reference to a empty session if none exist. </p>
<p>If no session corresponding to the host and IP exist, then this function will cycle through sessions in a rotating order. This allows the session cache to continually store sessions, however it will also result in old sessions being cleared and returned. In general, it is a good idea to use a SessionCache size equal to the number of domains you plan on connecting to.</p>
<p>The implementation for this function can be found at <a class="el" href="class_s_s_l_client_impl.html#ab4e38d4319ec504395d67d2ab21a639e">SSLClientImpl::get_session_impl</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A hostname c string, or NULL if one is not available </td></tr>
    <tr><td class="paramname">addr</td><td>An IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to an <a class="el" href="class_s_s_l_session.html" title="This class stores values which allow SSLClient to save and resume SSL sessions.">SSLSession</a> object </dd></dl>

</div>
</div>
<a id="a2d71f00d6634092f50c5262ad25cdacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d71f00d6634092f50c5262ad25cdacd">&#9670;&nbsp;</a></span>getSessionCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::getSessionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of SSL sessions that can be stored at once. </p>
<dl class="section return"><dt>Returns</dt><dd>The SessionCache template parameter. </dd></dl>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#a8e2385522ec04b1ce70871d4de23db6b">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a563c5f9829757075bf16742cffa4cf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563c5f9829757075bf16742cffa4cf73">&#9670;&nbsp;</a></span>localPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::localPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the local port, C::localPort exists. Else return 0. </p>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#a45f26385ee1975b12265943efb1ff0d5">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a2d378fbb7b8f15a1691746572f9d95b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d378fbb7b8f15a1691746572f9d95b1">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc" title="Check if the device is connected.">SSLClient::connected()</a> &gt; 0. </p>
<dl class="section return"><dt>Returns</dt><dd>true if connected, false if not </dd></dl>

</div>
</div>
<a id="a824b599264f893e1b206a9100bc52ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824b599264f893e1b206a9100bc52ee1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>SSLClient::operator bool </dd></dl>

</div>
</div>
<a id="adab82ba09345fa070712d3124af30e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab82ba09345fa070712d3124af30e1b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not two <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> objects do not have the same underlying client object. </p>

</div>
</div>
<a id="a505bfb6831a45aebf58d84e3b89d4cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505bfb6831a45aebf58d84e3b89d4cfc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>SSLClient::operator bool </dd></dl>

</div>
</div>
<a id="a5f40f8f4d26d21e14276c3e8162b62b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f40f8f4d26d21e14276c3e8162b62b9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not two <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> objects have the same underlying client object. </p>

</div>
</div>
<a id="a31742867b00bd8d130637af0935bacbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31742867b00bd8d130637af0935bacbd">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>View the first byte of the buffer, without removing it from the <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> Buffer. </p>
<p>The implementation for this function can be found in SSLClientImpl::peek </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> must be &gt;0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first byte received, or -1 if the preconditions are not satisfied (warning: do not use if your data may be -1, as the return value is ambiguous) </dd></dl>

</div>
</div>
<a id="aedf2746cc35da596faf8322776c2118e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf2746cc35da596faf8322776c2118e">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single byte, or -1 if none is available. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_s_l_client.html#afd6d7ae798c05cf566b2eb5651dba795" title="Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes re...">SSLClient::read(uint8_t*, size_t)</a> </dd></dl>

</div>
</div>
<a id="afd6d7ae798c05cf566b2eb5651dba795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6d7ae798c05cf566b2eb5651dba795">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read size bytes from the SSL client buffer, copying them into *buf, and return the number of bytes read. </p>
<p>This function checks if bytes are ready to be read by calling <a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a>, and if so copies size number of bytes from the IO buffer into the buf pointer. Data read using this function will not include any SSL or socket commands, as the Client and BearSSL will capture those and process them separately.</p>
<p>If you find that you are having a lot of timeout errors, <a class="el" href="class_s_s_l_client.html" title="The main SSLClient class. Check out README.md for more info.">SSLClient</a> may be experiencing a buffer overflow. Checkout <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> for more information.</p>
<p>The implementation for this function can be found in <a class="el" href="class_s_s_l_client_impl.html#a231b7b1bb2182cda1ed6e9d5ebf66afe">SSLClientImpl::read_impl(uint8_t*, size_t)</a></p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> must be &gt;0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer to put SSL application data into </td></tr>
    <tr><td class="paramname">size</td><td>The size (in bytes) to copy to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied (&lt;= size), or -1 if the preconditions are not satisfied. </dd></dl>

</div>
</div>
<a id="af76a0df76834e0d0999dbf44c7c0a174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76a0df76834e0d0999dbf44c7c0a174">&#9670;&nbsp;</a></span>remoteIP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IPAddress <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::remoteIP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the remote IP, if C::remoteIP exists. Else return INADDR_NONE. </p>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#ae97adc55212c1aa96880aac28dd71387">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a5974a5f8722a752f121af4fac498bb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5974a5f8722a752f121af4fac498bb22">&#9670;&nbsp;</a></span>remotePort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::remotePort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the remote port, if C::remotePort exists. Else return 0. </p>

<p>Implements <a class="el" href="class_s_s_l_client_impl.html#a93cdb32491fc08b035e40f840ff2e8f5">SSLClientImpl</a>.</p>

</div>
</div>
<a id="a5b626703a24089dbb0480a9b6ddf348c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b626703a24089dbb0480a9b6ddf348c">&#9670;&nbsp;</a></span>removeSession()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::removeSession </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IPAddress &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the session corresponding to a host and IP. </p>
<p>The implementation for this function can be found at <a class="el" href="class_s_s_l_client_impl.html#a6baed094969874fb9d2bea3a00ecbee1">SSLClientImpl::remove_session_impl</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A hostname c string, or NULL if one is not available </td></tr>
    <tr><td class="paramname">addr</td><td>An IP address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad30db47248d78df7c12dedfb27f06529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30db47248d78df7c12dedfb27f06529">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the connection. </p>
<p>If the SSL session is still active, all incoming data is discarded and BearSSL will attempt to close the session gracefully (will write to the network), and then call m_client::stop. If the session is not active or an error was encountered previously, this function will simply call m_client::stop. The implementation for this function can be found in SSLClientImpl::peek. </p>

</div>
</div>
<a id="a6b8ff53c10fe34aab1dc2561410f70bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8ff53c10fe34aab1dc2561410f70bb">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>SSLClient::write(uint8_t*, size_t) </dd></dl>

</div>
</div>
<a id="a6bcb7579ebc051c097acb794b95771a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcb7579ebc051c097acb794b95771a9">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , size_t SessionCache = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_s_s_l_client.html">SSLClient</a>&lt; C, SessionCache &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some bytes to the SSL connection. </p>
<p>Assuming all preconditions are met, this function writes data to the BearSSL IO buffer, BUT does not initially send the data. Instead, you must call <a class="el" href="class_s_s_l_client.html#a5d13fd2f32ee2ea65a1f3820f758e77e" title="Returns the number of bytes available to read from the data that has been received and decrypted.">SSLClient::available</a> or <a class="el" href="class_s_s_l_client.html#a2ee6a3134d07ca09cf61ee04d32c3d44" title="Force writing the buffered bytes from SSLClient::write to the network.">SSLClient::flush</a>, which will detect that the buffer is ready for writing, and will write the data to the network. Alternatively, if this function is requested to write a larger amount of data than SSLClientImpl::m_iobuf can handle, data will be written to the network in pages the size of SSLClientImpl::m_iobuf until all the data in buf is sent&ndash;attempting to keep all writes to the network grouped together. For information on why this is the case check out <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> .</p>
<p>The implementation for this function can be found in <a class="el" href="class_s_s_l_client_impl.html#a807656f814f24cf6cd711e429b716c4d">SSLClientImpl::write_impl(const uint8_t*, size_t)</a></p>
<dl class="section pre"><dt>Precondition</dt><dd>The socket and SSL layer must be connected, meaning <a class="el" href="class_s_s_l_client.html#a25e4414ab0c9424d09592f9567a678dc" title="Check if the device is connected.">SSLClient::connected</a> must be true. </dd>
<dd>
BearSSL must not be waiting for the recipt of user data (if it is, there is probably an error with how the protocol in implemented in your code).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the pointer to a buffer of bytes to copy </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to copy from the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied to the buffer (size), or zero if the BearSSL engine fails to become ready for writing data. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Noah/Documents/Arduino/libraries/SSLClient/src/<a class="el" href="_s_s_l_client_8h_source.html">SSLClient.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_s_l_client.html">SSLClient</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
